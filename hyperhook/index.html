<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hyperhook Documentation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
        }
        header {
            background: #333;
            color: #fff;
            padding: 10px 0;
            text-align: center;
        }
        h1 {
            margin: 0;
        }
        .github-link {
            display: block;
            margin-top: 5px;
            color: #007bff;
            text-decoration: none;
            font-weight: bold;
        }
        .github-link:hover {
            text-decoration: underline;
        }
        h2, h3 {
            color: #333;
        }
        ul, ol {
            margin: 10px 0;
            padding-left: 20px;
        }
        code {
            background: #eaeaea;
            padding: 2px 4px;
            border-radius: 4px;
        }
        footer {
            text-align: center;
            margin-top: 20px;
            font-size: 0.8em;
            color: #666;
        }
    </style>
</head>
<body>

<header>
    <h1>Hyperhook Documentation</h1>
    <a href="https://github.com/lbird90894/hyperhook.git" class="github-link" target="_blank">Goto GitHub Repository</a>
</header>

<h2>1. Introduction</h2>
<p>Since Windows x64, the kernel is protected by KPP(Kernel Patch Protection), making hooking impossible. This project is a WDM static library that hooks native functions in the kernel, bypassing KPP through virtualization.<br>
I haven't analyzed KPP closely, but it generally works like this:<br>
"KPP compares the static information about native functions in the kernel and the code of native functions in memory at random times, and generates a BSOD if they are different."</p>

<p style="margin-bottom: 1px;">Ideas for bypassing KPP through virtualization are as follows:</p>
<ol>
    <li>Virtualize memory through EPT.</li>
    <li>After patching the code in the function to be hooked, set the page permission to execute only.</li>
    <li>When calling the function, the hooked function is called.</li>
    <li>If KPP attempts to read the memory of the hooked function in guest mode, the host mode switches the hooked page back to the original page and changes the page permission to read-only.</li>
    <li>KPP reads the original page that is the result of the host's handling.<br>(Host mode means VMX root mode, and guest mode means VMX Non-root mode.)</li>
</ol>

<p style="margin-bottom: 1px;">This library includes the following:</p>
<ul>
    <li>
	A 1-byte(int3) patch is used instead of a 5-byte patch, as the latter may cause synchronization issues.
	<br>This approach hooks by utilizing interrupt handling instead of trampolines.
	</li>
	
    <li>
	The TLB flush for page swapping in host mode is processed per individual core.
	<br>The page status management depends on individual cores, but it does not affect overall functionality.
	<br>(It might be hard to understand, so think carefully about it.)
	</li>
    
	<li>Since the concept of IRQL cannot be used in host mode, I implemented spinlock and logger necessary for logging.
	<br>(Only some formats such as %d, %llx, and %s are supported.)
	</li>
    
	<li>The hypervisorâ€™s cache policy remains the same as the cache policy before the hypervisor was loaded.(MTRR, PAT...)</li>
    
	<li>EPT paging uses 2Mb pages, but when hooking, the page is split into 4Kb. When unhooking, the splitted 4Kb pages are merged back into 2Mb.</li>
    
	<li>Nested virtualization with other hypervisors like Hyper-V is not considered.</li>
</ul>
<br>
<h2>2. Environment</h2>
<ul>
    <li>CPU: Intel cpu that supports virtualization</li>
    <li>Memory: 512Gb or less</li>
    <li>OS: Windows 10 or higher (only x64 supported)</li>
</ul>
<br>
<h2>3. Configuration</h2>
<ul>
    <li>Hypervisor library (hyperhook.lib)</li>
    <li>Test driver for linking the hypervisor library (test.sys)</li>
    <li>Driver signature files to bypass KMCI (used only in Test B)</li>
</ul>
<br>
<h2>4. Test</h2>
<p>
The test consists of independent A and B.<br>
If you want to check kernel hooking through the hypervisor, perform Test A.<br>
If you want to verify kernel hooking through the hypervisor and bypass KPP, perform test B.
</p>

<h3 style="margin-bottom: -7px;">4.1. Test Environment</h3>
<p style="margin-bottom: 1px;">The environment that I tested on is as follows</p>
<ul>
    <li>vmware 15.5.7 ("Settings -> Hardware -> Processors -> Virtualize Intel VT-x/EPT or AMD-V/RVI" check)</li>
    <li>Guest OS: Windows 10 22h2 (19041)</li>
</ul>
<p>If you want to test on another version of Windows, check that the prologue of the NtCreateFile function to be hooked is as follows.<br>
<strong>sub rsp,88h</strong> <br>
<strong>xor eax,eax</strong> <br>
<strong>mov qword ptr [rsp+78h], rax</strong></p>

<h3 style="margin-bottom: -7px;">4.2. Log Configuration</h3>
<p style="margin-bottom: 1px;">To configure the log, run the log.reg file. The contents below provide a detailed explanation of the log.</p>
<ul>
    <li><strong>LogType</strong>: Determines whether to print to the kernel debugger or write to a file.<br>
    1: Print to kernel debugger, 2: Write to file, 3: Print to kernel debugger and write to file</li>
    
    <li><strong>LogLevel</strong>: Filters the logs to be output.<br>
    1: Only error messages are output, 2: Warning messages are also output, 3: No filtering</li>
    
    <li><strong>LogPath</strong>: Specifies the file path where the log file will be created.</li>
</ul>

<h3 style="margin-bottom: -7px;">4.3. Test A</h3>
<p style="margin-bottom: 1px;">After executing the log.reg file in Windows in a test mode environment, run the test.sys driver. You can check the log through C:\HKlog.txt, windbg + VirtualKD, dbgview64, etc.<br>
The expected results are as follows</p>
<ol>
    <li>The NtCreateFile function is hooked to print the file path.</li>
    <li>The OriginTest function is hooked, and the first byte of the function prologue is not 0xCC.<br>
    (The first byte of the OriginTest function is patched to 0xCC, but if the memory is accessed with read permission, the host handles this and reads the original memory before hooking.)</li>
</ol>

<h3 style="margin-bottom: -7px;">4.4. Test B</h3>
<p>KPP may be disabled in Windows in a test mode environment. Accordingly, to directly verify KPP bypass, it must be tested in normal mode. At this time, since the test driver does not have an HLK/HCK signature, it cannot be loaded by KMCI. However, I explain below how to change KMCI's policy to load self-signed drivers.</p>

<h4 style="margin-bottom: -7px;">Host OS</h4>
<ol>
    <li>"Settings -> Options -> Advanced -> UEFI -> Enable secure boot" check</li>
    <li>Move to the folder where the .vmx file of the guest OS exists.</li>
    <li>Copy PK_Cert.cer to that folder.</li>
    <li>Delete the .nvram file.</li>
    <li>Add the following content to the .vmx file.<br>
    <code>uefi.allowAuthBypass = "TRUE"</code><br>
    <code>uefi.secureBoot.PKDefault.file0 = "PK_Cert.cer"</code></li>
    <li>Boot the guest OS.</li>
</ol>

<h4 style="margin-bottom: -7px;">Guest OS</h4>
<ol>
    <li>Place the test folder in an appropriate location.</li>
    <li>Run SetBootPolicy.bat. (Several reboots may occur.)</li>
    <li>Sign the test.sys driver through SignDriver.bat.</li>
    <li>After executing the log.reg file, run test.sys through StartDriver.bat.<br>
    (You can check the log through C:\HKlog.txt, windbg + VirtualKD, dbgview64, etc.)</li>
</ol>

<p style="margin-bottom: 1px;">The expected results are as follows</p>
<ol>
    <li>The NtCreateFile function is hooked to print the file path.</li>
    <li>The OriginTest function is hooked, and the first byte of the function prologue is not 0xCC.<br>
    (The first byte of the OriginTest function is patched to 0xCC, but if the memory is accessed with read permission, the host handles this and reads the original memory before hooking.)</li>
    <li>Over time, KPP reads the memory of the NtCreateFile function, and the hypervisor handles it correctly, preventing a BSOD caused by KPP.<br>
	In my case, based on log analysis, KPP checked the integrity of the NtCreateFile function every 4 hours.</li>
</ol>

<h4 style="margin-bottom: -7px;">Optional</h4>
<ul>
    <li>If you want to check whether the general kernel hooking method causes BSOD by KPP, run KppCheck.sys alone.<br>
	A BSOD(CRITICAL_STRUCTURE_CORRUPTION) will probably occur within a day.</li>
    <li>If you want to create SiPolicy.xml yourself, use the attached WDACWizard.</li>
    <li>If you want to create certificates yourself, check the reference below.</li>
</ul>

<p>Please contact me if you have any questions or find bugs.<br>
(I am Korean, so I would appreciate it if you could ask your question in Korean or English.)</p>
<br>
<h2>5. Reference</h2>
<p style="margin-bottom: 2px;">Hypervisor Related</p>
<ul style="margin-top: 0; margin-bottom: 15px;">
    <li><a href="https://github.com/ionescu007/SimpleVisor">https://github.com/ionescu007/SimpleVisor</a></li>
    <li><a href="https://github.com/SinaKarvandi/Hypervisor-From-Scratch">https://github.com/SinaKarvandi/Hypervisor-From-Scratch</a></li>
    <li><a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html</a></li>
</ul>

<p style="margin-bottom: 2px;">Driver Signature Related</p>
<ul style="margin-top: 0; margin-bottom: 15px;">
    <li><a href="https://github.com/HyperSine/Windows10-CustomKernelSigners">https://github.com/HyperSine/Windows10-CustomKernelSigners</a></li>
    <li><a href="https://github.com/valinet/ssde">https://github.com/valinet/ssde</a></li>
    <li><a href="https://www.geoffchappell.com/notes/windows/license/customkernelsigners.htm">https://www.geoffchappell.com/notes/windows/license/customkernelsigners.htm</a></li>
    <li><a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/slmem/productpolicy.htm">https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/slmem/productpolicy.htm</a></li>
</ul>
<footer>
    <p>&copy; 2024 Hyperhook Documentation</p>
</footer>

</body>
</html>
